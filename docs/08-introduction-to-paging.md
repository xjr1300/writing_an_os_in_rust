# ページングの紹介

この投稿は*ページング*の紹介で、我々のオペレーティング・システムでも使用するとても一般的なメモリ管理機構です。
この投稿では、なぜメモリの隔離が必要とされ、*セグメンテーション*がどのように機能するか、*仮想メモリ*とは何か、そしてページングがどのようにメモリ断片化の問題を解決するかを説明します。
また、この投稿では、x86_64アーキテクチャ上の複数レベルのページ・テーブルのレイアウトを探求します。

このブログは[GitHub](https://github.com/phil-opp/blog_os)で公開で開発されています。
もし、問題や質問がある場合は、ここで問題（issue）を発行（open）してください。
[下で](https://os.phil-opp.com/paging-introduction/#comments)コメントを残すこともできます。
この投稿の完全なソースコードは、[`post-08`](https://github.com/phil-opp/blog_os/tree/post-08)ブランチで見つけることができます。

## メモリ保護

オペレーティング・システムの主要な作業の1つは、互いにプログラムを隔離することです。
例えば、Webブラウザはテキスト・エディタに干渉できるべきではありません。
この成果を得るために、オペレーティング・システムは、あるプロセスのメモリ領域が他のプロセスによってアクセスされないことを保証するために、ハードウェアの機能を利用します。
ハードウェアとOSの実装に依存して、異なる手法があります。

例として、あるARM Cortex-Mプロセッサ（組み込みシステムで使用される）は、少数のメモリ領域（例えば、8）を異なるアクセス権限（例えば、アクセス拒否、読み取り専用、読み書き可能）で定義できる、[メモリ保護機構](https://developer.arm.com/docs/ddi0337/e/memory-protection-unit/about-the-mpu)（MPU）があります。
それぞれのメモリ・アクセスにおいて、MPUはアドレスが正しいアクセス権限を持つ領域にあることを保証して、そうでない場合は例外をスローします。
それぞれのプロセスの切り替えによる領域やアクセス権限の変更によって、オペレーティング・システムは、それぞれのプロセスのみ、それ自身のメモリにアクセスすることを保証することで、互いにプロセスを隔離します。

x86において、ハードウェアは、[セグメンテーション](https://en.wikipedia.org/wiki/X86_memory_segmentation)と[ページング](https://en.wikipedia.org/wiki/Virtual_memory#Paged_virtual_memory)の2つの異なる手法をサポートしています。

## セグメンテーション

セグメンテーションは、アドレス指定可能なメモリの量を増やすことを目的に、1978年には既に導入されていました。
当時CPUはたった16ビットのアドレスしか使用しておらず、64キロバイトのアドレス指定可能なメモリ量に制限されていたことが背景にあります。
この64キロバイト以上をアクセス可能にするために追加のセグメント・レジスタが導入され、それはそれぞれはオフセット・アドレスが含まれていました。
CPUは、それぞれのメモリ・アクセスでこのオフセットを自動的に追加するため、それは最大1MiBのメモリまでアクセス可能になりました。

セグメント・レジスタは、メモリ・アクセスの種類によってCPUによって自動的に選択されます。
フェッチ命令ではコード・セグメント`CS`が使用され、スタック操作（プッシュ／ポップ）ではスタック・セグメント`SS`が使用されます。
他の命令はデータ・セグメント`DS`またはエクストラ・セグメント`ES`を使用します。
後に、`FS`と`GS`の2つのセグメントが追加され、それは自由に使用できます。

セグメンテーションの最初のバージョンにおいて、セグメント・レジスタはオフセットを直接含み、アクセス制御を実行できませんでした。
後に、これは[保護モード](https://en.wikipedia.org/wiki/X86_memory_segmentation#Protected_mode)の導入によって変更されました。
CPUがこのモードで実行しているとき、セグメント記述子はローカルまたはグローバル[記述子テーブル](https://en.wikipedia.org/wiki/Global_Descriptor_Table)にインデックスを含みます。記述子テーブルは、- オフセット・アドレスに加えて - セグメントのサイズとアクセス権限を含んでいます。
それぞれのプロセスで個別のグローバル／ローカル記述子テーブルをロードすることで、メモリ・アクセスをプロセス自身のメモリ領域に閉じ込めることで、OSはプロセスを互いに隔離できます。

実際のアクセスの前にメモリ・アドレスを変更することにより、セグメンテーションは、現在ほとんどどこでも使用されている技術をすでに使用しています。*仮想メモリ*です。

### 仮想メモリ

仮想メモリの背後にある考えは、基になる物理的なストレージ機器からメモリ・アドレスを抽象化することです。
ストレージ機器に直接アクセスすることに代わって、最初に変換ステップが実行されます。
セグメンテーションのために、その変換ステップは実際のセグメントのオフセット・アドレスを追加することです。
セグメント内のメモリ・アドレス`0x12340000`にオフセット`0x1111000`でアクセスするプログラムを想像してください。
実際にアクセスされるアドレスは`0x2345000`です。

2つのアドレスの種類を区分するために、変換前のアドレスは*仮想*と呼ばれており、変換後のアドレスは*物理*と呼ばれます。
2つの種類のアドレスの重要な違いの1つは、物理アドレスは一意であり、常に同じ個別のメモリ位置を参照します。
一方で、仮想アドレスは変換関数に依存します。
2つの異なる仮想アドレスが同じ物理アドレスを参照する可能性が十分にあります。
また、異なる変換関数を使用しているとき、同じ仮想アドレスが異なる物理アドレスを参照できます。

この属性が役立つ例は、同じプログラムが2回並行して実行するときです。

![segmentation same program twice](https://os.phil-opp.com/paging-introduction/segmentation-same-program-twice.svg)

ここの同じプログラムは、異なる変換関数で2回実行します。
最初のインスタンスは100のセグメント・オフセットを持っているため、仮想アドレス0-150は物理アドレスの100-250に変換されます。
2番めのインスタンスは300のオフセットを持っており、それは仮想アドレス0-150は物理アドレス300-450に変換します。
これは、両方のプログラムが、お互いに干渉することなく、同じコードを実行して、同じ仮想アドレスを使用できるようにします。

他の利点は、（2つの）プログラムが完全に異なる仮想アドレスを使用していても、プログラムは任意の物理メモリの位置に配置できることです。
よって、OSはプログラムを再コンパイルする必要なく、利用可能なすべてのメモリを使用できます。

### 断片化

仮想と物理アドレスの違いは、セグメンテーションをとても強化します。
しかしながら、それは断片化の問題があります。
例として、上記で確認したプログラムの3番めのコピーを実行することを想像してください。

![segmentation-fragmentation](https://os.phil-opp.com/paging-introduction/segmentation-fragmentation.svg)

十分な空きメモリが存在するにも関わらず、重なりなしでプログラムの3番目のインスタンスを仮想メモリにマップする方法がありません。
その問題は、連続したメモリを必要とすることと、小さな空きの塊を使用できないことです。

この断片化に対処する1つの方法は、実行を一時停止して、使用されているメモリの部分を互いに近くまで移動して、変換を更新して、そして実行を再開することです。

![segmentation-fragmentation-compacted](https://os.phil-opp.com/paging-introduction/segmentation-fragmentation-compacted.svg)

現在、プログラムの3番めのインスタンスを開始するために連続した十分なスペースがあります。

この断片化解消処理の欠点は、多くの量のメモリのコピーが必要になることで、パフォーマンスが減ります。
また、それはメモリがひどく断片化される前に、定期的に実行される必要があります。
これにより、プログラムがランダムに一時停止して、応答しなくなるため、パフォーマンスを予測できなくなります。

断片化の問題は、セグメントが多くのシステムでもはや使用されなくなった理由の1つです。
実際に、セグメンテーションはもはやx86の64bitモードでサポートされていません。
代わりに*ページング*が利用されており、それは完全に断片化の問題を回避します。

## ページング

その考えは、仮想と物理メモリ空間の両方を、小さな固定サイズのブロックに分割することです。
仮想メモリ空間のブロックは*ページ*と呼ばれ、物理アドレス空間のブロックは*フレーム*と呼ばれています。
それぞれのページは個々にフレームにマップできるため、大きなメモリ領域を非連続な物理フレームに分割できます。

この利点は、もし断片化されたメモリ空間の例を要約すると明らかになりますが、今回はセグメンテーションの代わりにページングを使用します。

![paging-fragmentation](https://os.phil-opp.com/paging-introduction/paging-fragmentation.svg)

この例において、50bytesのページ・サイズをもち、それぞれのメモリ領域が3つのページに分割されたことを意味します。
それぞれのページは個々にフレームにマップされたため、連続した仮想メモリ領域は、非連続な物理フレームにマップできます。
これは、前に断片化解消を実行することなしに、プログラムの3番めのインスタンスを実行できるようにします。

### 隠れた断片化

セグメンテーションと比較すると、ページングは少数の大きく可変サイズのメモリ領域の代わりに、多くの小さな固定サイズのメモリ領域を使用します。
すべてのフレームは同じサイズであり、使用するためには小さすぎるフレームは存在しないため、断片化は発生しません。

もしくは、断片化が発生しないように*見えます*。
いまだある隠された断片化があり、*内部断片化*と呼ばれています。
内部断片化は、すべてのメモリ領域が正確にページサイズの倍数でないために発生します。
上記例で、サイズ101のプログラムを想像してください。
それはサイズ50の3つのページを必要とするため、必要以上に49バイトを占有します。
断片化の2種類を区別するために、セグメンテーションを使用したときに発生する断片化の種類を*外部断片化*と呼びます。

内部断片化は不幸ですが、セグメンテーションで発生する外部断片化よりも良いです。
内部断片化はメモリを浪費しますが、断片化解消を要求せず、断片化の量を予測可能にします（メモリ領域あたり平均でページの半分）。

### ページ・テーブル

潜在的な数百万のページそれぞれが、個々にフレームにマップされることを確認しました。
このマッピング情報は、どこかに保存される必要があります。
セグメンテーションは、それぞれ有効なメモリ領域に個々のセグメント選択レジスタを使用しますが、レジスタよりもはるかに多くのページがあるためページングでは不可能です。
代わりに、ページングは、マッピング情報を保存するために、*ページ・テーブル*と呼ばれるテーブル構造を使用します。

上記の例において、ページ・テーブルはこのように見えます。

![paging page tables](https://os.phil-opp.com/paging-introduction/paging-page-tables.svg)

それぞれのプログラム・インスタンスがそれら独自のページ・テーブルを持つことを確認できます。
現在有効なテーブルへのポインタは特別なCPUレジスタに保存されます。
`x86`において、このレジスタは`CR3`と呼ばれています。
それぞれのプログラム・インスタンスが実行する前に、正確なページ・テーブルのポインタをこのレジスタにロードすることは、オペレーティング・システムの仕事です。

それぞれのメモリアクセスにおいて、CPUはレジスタからてーぶるへのポインタを読み込み、テーブル内のアクセス可能なページにマップされたフレームを探します。
これはすべてハードウェア内で実施され、実行しているプログラムからは完全に見えません。
変換処理をスピード・アップするために、多くのCPUアーキテクチャは、最後の変換結果を記憶する特別なキャッシュを持っています。

アーキテクチャによって、ページ・テーブルのエントリはフラグ・フィールド内でアクセス権限のよおうな属性を保存することもできます。
上記の例では、"r/w"フラグは読み書き可能にします。

### マルチレベル・ページ・テーブル

我々が確認した単純なページ・テーブルは大きなアドレス空間において問題があります。
それらはメモリを浪費します。
例えば、`0`、`1_000_000`、`1_000_050`そして`1_000_100`の4つの仮想ページを使用するプログラムを想像してください（桁区切りに`_`を使用しています）。

![single level page table](https://os.phil-opp.com/paging-introduction/single-level-page-table.svg)

4つの物理フレームしか必要としませんが、ページ・テーブルは数百万を超えるエントリがあります。
CPUは、変換処理内で正確なエントリに直接ジャンプすることができないため、空のエントリを切り捨てできません（例えば、4番目のページが4つ目のエントリを使用することを保証できません）。

メモリの浪費を減らすために、**2階層ページ・テーブル**を使用できます。
このアイデアは、異なるアドレス領域のために異なるページ・テーブルを使用することです。
*レベル2*と呼ばれる追加のページ・テーブルは、アドレス領域と（レベル1）ページ・テーブルのマッピングを含んでいます。

これは例によってうまく説明されています。
それぞれのレベル1ページ・テーブルは、サイズ`10_000`の領域について責任を持ちます。
そして、それに続くテーブルは上記の例のマッピングのために存在します。

![multilevel page table](https://os.phil-opp.com/paging-introduction/multilevel-page-table.svg)

ページ0は最初の`10_000`バイトの領域に分類されるため、レベル2ページ・テーブルの最初のエントリを使用します。
このエントリは、ページ`0`がフレーム`0`を指し示すことを示した、レベル1ページ・テーブル`T1`を指し示します。

ページ`1_000_000`、`1_000_050`と`1_000_100`全ては100番目の`10_000`バイトの領域に分類されるため、それらはレベル2ページ・テーブルの100番目のエントリを使用します。
このエントリは、3つのページをフレーム`100`、`150`そして`200`にマップする、異なるレベル1ページテーブル`T2`を指し示します。
レベル1テーブル内のページ・アドレス領域のオフセットを含んでいないことに注意してください。
例えば、ページ`1_000_050`のエントリは`50`です。

レベル2テーブル内に100の空のエントリがありますが、前の数百万の空のエントリよりもとても少ないです。
これらの節約の理由は、`10_000`と`1_000_000`の間のマップされていないメモリ領域のための、レベル1ページ・テーブルを作成する必要がないからです。

2階層ページ・テーブルの原理は、3階層、4階層またはより多くの階層に拡張できます。
そして、ページ・テーブル・レジスターは最上階層を指し示し、それは次の下の階層のテーブルを指し示し、またそれは次の下の階層のテーブルを指し示し、というように続きます。
レベル1ページ・テーブルはマップされたフレームを指し示します。
その原則は、一般的に*マルチレベル*または*階層ページ*テーブルと呼ばれています。

現在、ページとマルチレベル・ページ・テーブルがどのように機能するか理解しており、x86_64アーキテクチャでページングがどのように実装されているか確認できます（次はCPUが64ビットモードで動作していることを想定しています）。

## x86_64におけるページング

x86_64アーキテクチャは、4階層ページ・テーブルと4キロバイトのページサイズを使用しています。
それぞれのページ・テーブルは、レベルに関係なく、512エントリの固定サイズを持ちます。
それぞれのエントリは8バイトのサイズを持つため、それぞれのテーブルは`512 * 8B = 4KiB`の大きさで、1つのページに正確に収まります。

> 64ビットCPUであるため、エントリは8バイト（64ビット）のサイズをもつ。

それぞれのレベルのページ・テーブル・インデックスは、仮想アドレスから直接導出されています。

![x86_64 table indices from address](https://os.phil-opp.com/paging-introduction/x86_64-table-indices-from-address.svg)

それぞれのテーブル・インデックスを9ビットで構成して、それぞれのテーブルは2^9=512エントリを持つため妥当です。
最下位の12ビットは4キロバイト・ページ内のオフセットです（2^12バイト = 4キロバイト）。
ビット48から64ビットは捨てられており、48ビットアドレスのみサポートしているため、実際には64ビットではありません。

ビット48から64は廃棄されているので、それらは任意の値が設定されません。
代わりに、この範囲のすべてのビットは、アドレスを一意にし続けて、将来、5階層ページ・テーブルのように拡張できるようにします。
これは、[2の補数における符号拡張](https://en.wikipedia.org/wiki/Two's_complement#Sign_extension)にとてもよく似ているがめ、*符号拡張*と呼ばれています。
アドレスが正確に符号拡張されなかったとき、CPUは例外をスローします。

最近の"Ice Lake"インテルCPUがオプションで、仮想アドレスを48ビットから57ビットに拡張するために、[5階層ページ・テーブル](https://en.wikipedia.org/wiki/Intel_5-level_paging)をサポートすることは注目に値します。
特定のCPUのために我々のカーネルを再液化することは、この段階では意味がないため、この投稿では標準の4階層ページ・テーブルのみを使用します。

### 変換の例

どのように変換処理が機能するか詳細に理解するために例に進みましょう。

![x86_64 page table translation](https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg)

4階層ページ・テーブルのルートとなる、現在有効なレベル4ページテーブルの物理アドレスは`CR3`レジスタに保存されています。
それぞれのページ・テーブル・エントリは物理フレームまたは次のレベル・テーブルを指し示しています。
レベル1テーブルのエントリは、マップされたフレームを指し示します。
ページ・テーブル内のすべてのアドレスは、仮想の代わりに物理であることに注意しえください。なぜなら、そうでないとCPUはそれらのアドレスを変換する必要があるでしょう（それは決して終わらない再帰に陥る可能性があります）。

上記ページ・テーブルの階層は、2つのページ（青）をマップします。
ページ・テーブル・インデックスから、`0x803FE7F000`と`0x803FE00000`の2つのページの仮想アドレスを削減できます。
プログラムがアドレス`0x803FE7F5CE`から読み込みを試みたときに何が発生するか確認しましょう。
最初に、アドレスをバイナリに変換して、アドレスのためにページ・テーブル・インデックスとページ・オフセットを決定します。

![x86_64 page table translation addresses](https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation-addresses.png)

これらのインデックスを使用して、ページ・テーブル階層をたどって、アドレスがマップされたフレームを特定できるようになりました。

* `CR3`レジスタからくるレベル4テーブルのアドレスを読み込みことによって開始します。
* レベル4インデックスは1なので、そのテーブルのインデックス1を持つエントリを確認して、それはレベル3テーブルが保存されたアドレス16KiBを伝える。
* そのアドレス（16KiB）からレベル3テーブルをロードして、インデックス0のエントリを確認して、それはレベル2テーブルのある24KiBを指し示す。
* レベル2インデックスが511のため、レベル1テーブルのアドレスを探すために、ページの最後のエントリを確認する。
* レベル1テーブルのインデックス127のエントリから、ページがフレーム12KiB、または16進数で 0x3000にマッピングされていることが最終的にわかります。
* 最後のステップでは、ページ・オフセットをフレーム・アドレス追加して、物理アドレス0x3000 + 0x5ce = 0x35ceを取得します。

![x86_64 page table translation steps](https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation-steps.svg)

レベル1テーブルのページの権限は`r`で、それは読み込み専用を意味します。
ハードウェハこれらの権限を強制して、もしそのページへの書き込みを試みた場合、例外をスローするでしょう。
最階層の権限は下位層で可能な権限を制限するため、レベル3エントリを読み取り専用に設定すると、下位レベルで読み取り／書き込み権限が指定されていても、このエントリを使用するページは書き込み可能になりません。

この例はそれそれのテーブルの1つのインスタンスのみに使用しましたが、通常、それぞれのアドレス空間にはそれぞれのレベルの複数インスタンスがあることに注意することは重要です。
最大で次のものがあります。

* 1個のレベル4テーブル
* 512個のレベル3テーブル（レベル4テーブルは512のエントリを持つため）
* 512 * 512個のレベル2テーブル（それぞれ512個のレベル3テーブルは512のエントリを持つため）
* 512 * 512 * 512個のレベル1テーブル（レベル２テーブルごとに512エントリ）

### ページ・テーブル・フォーマット

x86_64アーキテクチャのページ・テーブルは、基本的に512エントリを持つ配列です。
Rust構文では次のようになります。

```rust
#[repr(align(4096))]
pub struct PageTable {
    entries: [PageTableEntry; 512],
}
```

`repr`属性によって示されたように、ページ・テーブルは、例えば4キロバイト境界で整列されるなど、ページが整列されている必要になります。
この要求事項は、ページ・テーブルが常に完全なページで満たされることを保証して、エントリをとても小さくする最適化を可能にします。

それぞれのエントリは8バイト（64ビット）の大きさで、次の書式があります。

| ビット | 名前                  | 意味                                                                                                                               |
| ------ | --------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| 0      | present               | ページが現在メモリ内にある                                                                                                         |
| 1      | writable              | このページの書き込みを許可                                                                                                         |
| 2      | user accessible       | セットされていなければ、カーネル・モードコードのみこのページにアクセスが可能                                                       |
| 3      | write-through caching | 直接メモリに書き込み                                                                                                               |
| 4      | disable cache         | このページのためにキャッシュが使用されない                                                                                         |
| 5      | accessed              | このページを使用したとき、CPUがこのビットをセット                                                                                  |
| 6      | dirty                 | このページへの書き込みがあったとき、CPUがこのビットをセット                                                                        |
| 7      | huge page/null        | P1とP4において0でなければならず、P3で1ギガバイトのページを作成して、P2で2メガバイトのページを作成                                  |
| 8      | global                | アドレス空間の切り替えによって、ページがキャッシュからフラッシュされていない（CR4レジスタのPGEビットがセットされなければならない） |
| 9-11   | available             | OSによって自由に使用されることができる                                                                                             |
| 12-51  | physical address      | フレームまたは次のページ・テーブルの52ビットで整列された物理アドレス                                                               |
| 52-62  | available             | OSによって自由に使用されることができる                                                                                             |
| 63     | no execute            | このページのコードを実行を禁止（EFERレジスタのNXEビットがセットされなければならない）                                              |

ビット12-51は物理フレームアドレスを保存するために使用されていることを確認しました。
残りのビットはフラグまたはオペレーティング・システムが自由に使用できるかを表すフラグです。
これが可能な理由は、4096バイトで整列されたアドレスを、それか整列されたページのページ・テーブルまたはマップされたフレームの開始位置を常に指し示すからです。
これは、ビット0-11は常に0で、それはハードウェアはアドレスを使用する前に単にそれらをゼロに設定出来るため、これらのビットを保存する理由がないからです。
x86_64アーキテクチャは52ビットの物理アドレスのみをサポートしているため、ビット52-63も同じです（それが48ビット仮想アドレスのみをサポートする方法と同じです）。

利用可能なフラグを注意深く確認しましょう。

* `present`フラグは、マップされたページとマップされていないページを区別します。
  それはメイン・メモリがいっぱいになったとき、一時的にディスクにページをスワップ・アウトするために使用できます。
  次にそのページにアクセスされたとき、*ページ・フォルト*と呼ばれる特別な例外が発生します。
  オペレーティング・システムは、ディスクから存在しないページをリロードして、プログラムを続行することで対応できます。
* `writable`と`no execute`フラグは、それぞれページのコンテンツが書き込み可能か、実行可能な命令を含むかを表します。
* `accessed`と`dirty`フラグは、読み込みまたは書き込みがそのページに発生したときに、CPUによって自動的にセットされます。
  この情報は、オペレーティング・システムによって活用されます。
  例えば、どのページをスワップ・アウトするか決定するために、またはページの内容は最後にディスクに保存してから変更されたかなどにです。
* `write-through caching`と`disable cache`フラグは、すべてのページのキャッシュを個々に制御できます。
* `user accessible`フラグは、ページをユーザー空間のコードで使用できるようにして、それ以外の場合は、CPUがカーネル・モードのときにのみアクセスできます。
  この機能は、ユーザー空間のプログラムが実行している間に、カーネルをマップしたままにすることで、[システム・コール](https://en.wikipedia.org/wiki/System_call)を高速化するために使用できます。
  しかしながら、それにも関わらず、[スペクトラ](https://en.wikipedia.org/wiki/Spectre_(security_vulnerability))脆弱性が、ユーザー空間のプログラムはこれらのページを読み込みできるようにします。
* `global`フラグは、ページがすべてのアドレス空間で使用可能であるため、アドレス空間の切り替えで変換キャッシュから削除する必要がないことをハードウェアに通知します (以下のTLBに関するセクションを参照してください)。 このフラグは、一般にカーネル・コードをすべてのアドレス空間にマップするために、クリアされた`user accessible`フラグと一緒に使用されます。
* `huge page`フラグは、レベル2またはレベル3ページ・テーブルのエントリがマップされたフレームを直接指し示すようにすることで、より大きなサイズのページを作成できます。
  このビットをセットすると、ページ・サイズは512倍に増加し、レベル2エントリの場合は 2 メガバイト = 512 * 4 キロバイト、レベル3エントリの場合は 1 ギガバイト = 512 * 2 メガバイトになります。
  より大きなページを使用する利点は、変換キャッシュの行と必要なページ テーブルが少なくなることです。

`x86_64`クレートは、[ページ・テーブル](https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/page_table/struct.PageTable.html)とそれらの[エントリ](https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/page_table/struct.PageTableEntry.html)の型を提供しているため、これらの構造体を我々自身が作成する必要がありません。

### 変換ルックアサイド・バッファ

4階層ページ・テーブルは、それぞれの変換が4回のメモリ・アクセスを要求するため、仮想アドレスの変換はコスト大きいです。
パフォーマンスを改善するために、x86_64アーキテクチャは、過去数個の変換結果を*変換ルックアサイド・バッファ*（TLB）にキャッシュします。
これにより、変換結果がキャッシュされているとき、変換をスキップできます。

他のCPUキャッシュと異なり、TLBは十分に透過性がなく、ページ・テーブルの内容が変更されたとき、変換結果を更新または削除できません。
これは、カーネルがページ・テーブルを変更したときは、いつでもカーネルはTLBを手動で更新しなければなりません。
これをするために、TLBから指定したページの変換結果を削除する[`invlpg`](https://www.felixcloutier.com/x86/INVLPG.html)（"不正なページ"）と呼ばれる特別なCPU命令があるため、次のアクセスでページ・テーブルから再度ロードされます。
また、TLBは`CR3`レジスタの再ロードによって完全に更新されるため、アドレス空間の切り替えをシミュレーションします。
`x86_64`クレートは、[`tlb`モジュール](https://docs.rs/x86_64/0.14.2/x86_64/instructions/tlb/index.html)内に両方の違いをRust関数として提供しています。

それぞれのページ・テーブルの変更をTLBにフラッシュすることを覚えていることは重要です。なぜなら、そうでない場合、CPUは古い変換の使用を続けるため、CPUはデバッグが非常に困難な非決定的なバグを導く可能性があります。

## 実装

我々がまだ言及していないことが1つあります。
**我々のカーネルは既にページングで実行しています。**
["最小のRustカーネル"]()の投稿で追加したブートローダーは、我々のカーネルのすべてのページと物理フレームをマップした、4層ページ階層を既に準備しています。
ブートローダーは、64ビット・モードのx86_64においてページングは必須であるため、これをしています。

これは、我々のカーネル内で使用したすべてのメモリ・アドレスは仮想アドレスだったことを意味します。
アドレス`0xb8000`にあるVGAバッファへのアクセスのみ機能しました。それは、ブートローダがそのメモリ・ページに等しくマップしたからです。また、それは仮想ページ`0xb8000`を物理フレーム`0xb8000`にマップしたことを意味します。

範囲外のすべてのメモリ・アクセスは、ランダムな物理メモリへの書き込みに代わり、ページ・フォルト例外を起こすため、ページングは我々のカーネルを比較的安全にしています。
ブートローダーはそれぞれのページに正しいアクセス権限を設定するので、それはページに含まれているコードのみが実行可能で、データ・ページのみが書き込み可能であることを意味します。

### ページ・フォルト

我々のカーネルのメモリ範囲外へのアクセスによってページ・フォルトを起こしてみましょう。
最初に、ページ・フォルト・ハンドラを作成して、我々のIDT内にそれを登録することで、一般的な[ダブル・フォルト](https://os.phil-opp.com/double-fault-exceptions/)の代わりにページ・フォルト例外を確認できます。

```rust
// in src/interrupts.rs

lazy_static! {
    static ref IDT: InterruptDescriptorTable = {
        let mut idt = InterruptDescriptorTable::new();

        […]

        idt.page_fault.set_handler_fn(page_fault_handler); // new

        idt
    };
}

use x86_64::structures::idt::PageFaultErrorCode;
use crate::hlt_loop;

extern "x86-interrupt" fn page_fault_handler(
    stack_frame: InterruptStackFrame,
    error_code: PageFaultErrorCode,
) {
    use x86_64::registers::control::Cr2;

    println!("EXCEPTION: PAGE FAULT");
    println!("Accessed Address: {:?}", Cr2::read());
    println!("Error Code: {:?}", error_code);
    println!("{:#?}", stack_frame);
    hlt_loop();
}
```

ページ・フォルトの発生により、[`CR2`](https://en.wikipedia.org/wiki/Control_register#CR2)レジスタはCPUによって自動的にセットされ、ページ・フォルトを引き起こしたアクセス済みの仮想アドレスが含まれています。
それを読み込んで出力するために、`x86_64`クレートの[`Cr2::read`](https://docs.rs/x86_64/0.14.2/x86_64/registers/control/struct.Cr2.html#method.read)関数を使用します。
[`PageFaultErrorCode`](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.PageFaultErrorCode.html)型は、例えば、読み込みまたは書き込み操作によって発生したのかなど、ページ・フォルトを起こしたメモリ・アクセスの種類について詳細な情報を提供します。
この理由で、我々はそれを出力します。
ページ・フォルトを解決しないで、実行を継続することはできないため、最後の[`hlt_loop`](https://os.phil-opp.com/hardware-interrupts/#the-hlt-instruction)に入ります。

現時点で、我々のカーネルの外側のメモリにアクセスすることを試行できます。

```rust

#[no_mangle] // don't mangle the name of this function
pub extern "C" fn _start() -> ! {
    println!("Hello World{}", "!");

    blog_os::init();

    // new
    let ptr = 0xdeadbeaf as *mut u32;
    unsafe {
        *ptr = 42;
    }

    // as before
    #[cfg(test)]
    test_main();

    println!("It did not crash!");
    blog_os::hlt_loop();
}
```

それを実行したとき、我々のページ・フォルト・ハンドラが呼ばれたことを確認できます。

![qemu page fault](https://os.phil-opp.com/paging-introduction/qemu-page-fault.png)

`CR2`レジスタは、たしかに`0xdeadbeaf`を含んでいて、それはアクセスを試行したアドレスです。
エラー・コードは[`CAUSED_BY_WRITE`]()を介して、その失敗が書き込み操作の実行を試行したことで発生したことを伝えています。
[設定されていないビット](https://docs.rs/x86_64/0.14.2/x86_64/structures/idt/struct.PageFaultErrorCode.html)を介してより詳細を伝えています。
例えば、`PROTECTION_VIOLATION`フラグがセットされていない事実は、パージ・フォルトは、目的のページが存在しないことが理由で発生したことを意味しています。

現在の命令ポインタが`0x2031b2`であることを確認したので、このアドレスはコード・ページを指し示していることがわかります。
コード・ページは、ブートローダーによって読み込み専用にマップされたため、このアドレスからの読み込みは機能しますが、書き込みはページ・フォルトを起こします。
`0xdeadbeaf`ポインタを`0x2031b2`に変更することで、これを試せます。

```rust
// Note: The actual address might be different for you. Use the address that
// your page fault handler reports.
let ptr = 0x2031b2 as *mut u32;

// read from a code page
unsafe { let _x = *ptr; }
println!("read worked");

// write to a code page
unsafe { *ptr = 42; }
println!("write worked");
```

最後の行をコメントアウトすることで、読み込みアクセスが機能したことを確認できますが、書き込みアクセスはページ・フォルトを起こします。

![qemu page fault protection](https://os.phil-opp.com/paging-introduction/qemu-page-fault-protection.png)

*"read worked"*メッセージが出力されたことを確認したため、それは読み込み操作がエラーを起こさなかったことを示しています。
しかしながら、*"write worked"*メッセージの代わりにページ・フォルトが発生しました。
今回は、[`PROTECTION_VIOLATION`]()フラグに加えて[`CAUSED_BY_WRITE`]()フラグが設定され、ページが存在したが、操作が許可されなかったことを示します。
この場合、コード・ページは読み取り専用としてマップされるため、ページへの書き込みは許可されません。

### ページ・テーブルへのアクセス

どのように我々のカーネルがマップされたかを定義するページ・テーブルを注意深く確認しましょう。

```rust
// in src/main.rs

#[no_mangle]
pub extern "C" fn _start() -> ! {
    println!("Hello World{}", "!");

    blog_os::init();

    use x86_64::registers::control::Cr3;

    let (level_4_page_table, _) = Cr3::read();
    println!("Level 4 page table at: {:?}", level_4_page_table.start_address());

    […] // test_main(), println(…), and hlt_loop()
}
```

`x86_64`の[`Cr3::read`](https://docs.rs/x86_64/0.14.2/x86_64/registers/control/struct.Cr3.html#method.read)関数は、`CR3`レジスタから現在有効なレベル4ページ・テーブルを返却します。
それは[`PhysFrame`](https://docs.rs/x86_64/0.14.2/x86_64/structures/paging/frame/struct.PhysFrame.html)と[`Cr3Flags`](https://docs.rs/x86_64/0.14.2/x86_64/registers/control/struct.Cr3Flags.html)のタプル型を返却します。
我々はそのフレームのみに興味があるため、タプルの2番めの要素を無視しています。

それを実行したとき、次の出力を確認できます。

```
Level 4 page table at: PhysAddr(0x1000)
```

現在有効なレベル４ページ・テーブルは、[`PysAddr`](https://docs.rs/x86_64/0.14.2/x86_64/addr/struct.PhysAddr.html)ラッパー型によって示されたように、*物理メモリ*内のアドレス`0x1000`に保存されています。
現時点での質問は、どのように我々のカーネルからこのテーブルにアクセスできるのか？です。

ページングが有効なとき、プログラムは容易にメモリ保護を回避して、他のプログラムのメモリにアクセスできるため、直接物理メモリにアクセスすることは不可能です。
よって、テーブルにアクセスする唯一の方法は、アドレス`0x1000`にある物理フレームにマップされたある仮想ページを解することです。
ページ・テーブル・フレームにマッピングを作成する問題は、定期的にカーネルがページ・テーブルにアクセスする必要があるため、一般的な問題です。例えば、新しいスレッドのために、いつスタックを確保するのかなどです。

この問題の解決策は、次の投稿で詳細に説明します。

## まとめ

この投稿では、セグメンテーションとページングという2つのメモリ保護手法を紹介しました。
前者は可変サイズのメモリ領域を使用し、外部の断片化に悩まされますが、後者は固定サイズのページを使用し、アクセス許可をよりきめ細かく制御できます。

ページングは、ページのマッピング情報を1つ以上のレベルでページ・テーブルに格納します。
x86_64アーキテクチャは、4レベルのページ・テーブルと 4キロバイトのページ・サイズを使用します。
ハードウェアはページ・テーブルを自動的に走査し、結果の変換を変換ルックアサイド・バッファー （TLB）にキャッシュします。
このバッファは透過的に更新されないため、ページ・テーブルの変更時に手動でフラッシュする必要があります。

カーネルが既にページングの上で実行されており、不正なメモリ・アクセスがページ・フォールト例外を引き起こすことがわかりました。
現在有効なページ・テーブルにアクセスしようとしましたが、カーネルから直接アクセスできない物理アドレスがCR3レジスタに格納されているため、アクセスできませんでした。

## 次は何ですか？

次の投稿では、カーネルでページングのサポートを実装する方法について説明します。
カーネルから物理メモリにアクセスするさまざまな方法を提示し、カーネルが実行されているページ・テーブルにアクセスできるようにします。
現時点で、仮想アドレスを物理アドレスに変換し、ページ・テーブルに新しいマッピングを作成する関数を実装できます。
